<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Extra for pointers and heap</title>
  <link rel="stylesheet" href="/assets/style.css">
</head>
<body>
  <header>
    <h1>extra notes for PATH, pointers and heap chapter</h1>
    <nav>
      <a href="/index.html">Home</a>
      <a href="/about.html">About</a>
      <a href="/technical.html">Technical</a>
      <a href="/personal.html">Personal</a>
      <a href="/fanfiction.html">Fanfiction</a>
    </nav>
  </header>

  <!-- content -->
  <main class="reading">
    <p class="reveal"> Windows环境下的PATH：提供可执行文件的绝对路径。可执行文件在CMD（command prompt）中
      执行。在PATH中设置路径后，则运行改路径下的可执行文件时，可以直接输入该文件的无后缀名称来运行，因此在任何
      工程目录下，命令都可以执行。（注：Windows将各种内容用后缀区分，而基于Unix的操作系统（如Linux）将所有内容统一视为文件。）
    </p>
    <p class="reveal"> 命令：操作系统上某个可执行文件的文件名。CMD也可被视为可执行文件，类似软件。例子：打开.txt时
    Windows把.txt绝对路径作为参数传给notepad（可执行文件/软件本身）。notepad通过绝对路径读取.txt内容，然后在GUI
    界面上渲染并向用户展示。</p>
    <p class="reveal"> 当CMD运行时，它首先判断文件名是否包含绝对路径。若包含，则只在绝对路径下
      寻找对应的可执行文件；若没找到则直接报错。若文件名不包含绝对路径，CMD会在CMD所操作的目录下寻找
      可执行文件。若还没找到，CMD会去OS内置命令中找。若还没找到，则去环境变量PATH记载目录中找
      可执行文件。以上流程都搜索完后，若还是没有找到，CMD就会报错。
    </p>
    <p class="reveal"> 堆：一个全局的存储空间。任何线程都可以在堆上申请空间。因此申请堆内存必须同步处理，
      否则会出现线程堵塞的问题。同时，也要进行垃圾对象回收管理，以免内存溢出。</p>
      <p class="reveal"> 由于栈的first in last out特性， 栈帧生命周期不能超过其被调用的作用域。
      栈上数据在函数返回时会被释放，因此栈上原有的数据无法被传输到函数外部。
    因此，生命周期较长的数据（指在退出作用域也不消失）只能放到一个全局的存储空间，
  也就是堆(heap)上。</p>
      <p class="reveal"> 线程：执行流课调用的最小单元。为过程中单一的控制流。
        由线程ID、指令指针、寄存器、堆栈构成。每个程序都至少由一个线程。若程序
      只有一个线程，则其为程序本身。</p>
      <p class="reveal"> 进程：进程由线程构成。进程由独立的地址空间，但线程没有单独地址空间。
        因此，同一进程的线程共享进程的地址空间。多进程可被分为并行、串行、并发等。 </p>
      
    
  </main>

  <!-- 🔹 Scroll reveal script -->
  <script>
    const reveals = document.querySelectorAll('.reveal');
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.1 });

    reveals.forEach(r => observer.observe(r));
  </script>
</body>
</html>
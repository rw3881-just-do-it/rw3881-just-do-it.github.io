<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>More Understanding runtime and memory</title>
  <link rel="stylesheet" href="/assets/style.css">
</head>
<body>
  <header>
    <h1>Extra notes for runtime and memory</h1>
    <nav>
      <a href="/index.html">Home</a>
      <a href="/about.html">About</a>
      <a href="/technical.html">Technical</a>
      <a href="/personal.html">Personal</a>
      <a href="/fanfiction.html">Fanfiction</a>
    </nav>
  </header>

  <!-- content -->
  <main class="reading">


    <p class="reveal"> 
              When I repeatedly submit the same code on LeetCode, I notice that the Runtime and Memory results are not necessarily the same as the previous submission.
        This shows that Runtime and Memory are not determined solely by the code itself;
        there are many other factors that affect execution time and memory usage. I therefore did some brief research
        and recorded some interesting findings here.
    </p>
    <br />
    <p class="reveal">
        *Runtime:<br />
        -Cache warmth: whether the instruction cache and data cache need to reload data.<br />
        -Branch predictor state: see below.<br />
        -Heap layout: sequential access is faster than random access. This is because sequential access uses contiguous
            memory addresses, while random access (such as using pointers)
            involves additional indirection, which costs more time.<br />
        -Operating System scheduling<br />
        *Memory:<br />
        -Padding: processors read data in fixed-size blocks. When the actual data size is insufficient,
            the compiler automatically adds padding, trading memory usage for execution speed.<br />
        -Standard Library: related to heap layout. For example, vector stores elements contiguously, while list uses pointers.<br />
        -Virtual layout: this makes branch prediction harder, for example, base->foo().<br />
    </p>
    <br />
    <p class="reveal">Runtime - Clock speed<br />
        The clock frequency (main frequency, clock speed) directly determines the instruction execution speed of a processor.
        Each clock oscillation generates a pulse signal, and each clock pulse allows the processor to perform one step of operation.
        Therefore, a higher frequency means the processor generates more pulse signals per unit time,
        allowing it to complete more logical operations (such as data transfer and computation) within the same time.
        A higher frequency also means a shorter clock period,
        so the same instruction can be completed in less time.<br />
        The higher the clock frequency, the higher the requirements for power consumption and heat dissipation.<br />
        Base clock: the motherboard clock frequency, which is directly related to the speed at which the CPU exchanges data
        with external components (memory, chipset, etc.).
        Multiplier: a factor (see the formula below) that allows the processor to run at a speed higher than the external bus speed.<br />
        CPU frequency = Base clock Ã— Multiplier <br />
        *Overclocking: a phenomenon in which hardware is manually configured (by adjusting the multiplier or base clock)
        to achieve higher performance. Increasing the base clock improves overall performance but may cause issues such as
        motherboard overheating; increasing the multiplier mainly affects processor speed and may also lead to CPU overheating.
        Therefore, overclocking requires careful attention to cooling and power consumption.<br />
        *Underclocking: the opposite of overclocking, where the multiplier or base clock is manually reduced
        to lower heat generation and power consumption.<br />
    </p>
    <br />
    <p class="reveal">Runtime - Clock <br /> 
        Each clock oscillation generates a pulse signal, and each clock pulse allows the processor to perform one step of operation.
        The clock controls logic gates and flip-flops.
        Flip-flops receive new values at each clock edge (see the next definition) and pass them to logic gates for processing.<br />
        By splitting logic gates into blocks and linking these small blocks with flip-flops,
        the number of cycles required to execute instructions can be effectively reduced.
    </p>
    <br />
    <p class="reveal">Runtime - Instruction Pipeline <br />
        Instruction pipelining (pipeline for short) is a technique that divides the processing of computer instructions
        into four independent stages and allows different instructions to overlap and execute these stages in hardware.
        These four stages, in order, are â€œFetch, Decode, Execute, Write-back.â€
        Splitting instructions into multiple stages corresponds exactly to the previously mentioned
        distribution of logic gates into separate blocks.<br />
        The pipeline depth refers to the number of independent and sequential stages into which a processor divides
        the execution of an instruction or operation. The greater the depth, the more finely instructions are split,
        and the simpler the logic at each stage, which helps increase clock frequency and throughput.
        However, it also leads to higher register area overhead and higher recovery costs when branch prediction
        (see below) fails.
    </p>
    <br />
    <p class="reveal">Runtime - Branch Predictor <br />
        A branch predictor is a type of digital circuit. Before a branch instruction is executed,
        it attempts to identify implicit patterns in how data is handled under this branch instruction
        based on execution history. While the branch instruction is being processed,
        it guesses which branch will be taken and speculatively executes the instructions
        of that subsequent branch in advance.<br />
        *Branch instruction: a conditional branch usually has two possible execution paths.
        If the condition result is â€œnot taken,â€ the JMP instruction is skipped and execution continues sequentially;
        if the result is â€œtaken,â€ the JMP instruction is executed, jumping to another block of program memory.<br />
        Branch predictors can avoid pipeline bubbling. Without a branch predictor, the pipeline must wait
        until the branch instruction passes the execute stage before sending the next instruction into the fetch stage,
        which introduces additional waiting time. Therefore, when a branch instruction enters the fetch stage,
        the branch predictor uses execution history to guess the outcome and speculatively execute one branch in advance,
        reducing potential time wasted waiting for instruction results.
        This method of guessing and executing is called speculative execution.<br />
        After the branch instruction is executed, if the prediction is correct, the pipeline continues normally.
        If the prediction is wrong, all intermediate results from speculative execution in the pipeline are discarded,
        and the processor fetches and executes instructions from the correct branch path.
        As a result, a misprediction wastes the pipeline stages before write-back,
        typically costing 10 to 20 clock cycles depending on the processor design.
    </p>
    <br />

      
    <p class="reveal">å½“æˆ‘åœ¨LeetCodeä¸Šåå¤æäº¤åŒä¸€ä¸ªä»£ç æ—¶ï¼Œæˆ‘å‘ç°Runtimeå’ŒMemoryä¸ä¸€å®šå’Œä¸Šä¸€æ¬¡æäº¤çš„ç»“æœä¸€æ ·ã€‚è¿™è¯´æ˜Runtimeå’ŒMemoryä¸ä»…ä»…å’Œä»£ç æœ¬èº«ç›¸å…³ï¼Œ
        è¿˜æœ‰æ›´å¤šçš„å› ç´ ä¼šå½±å“Runtimeçš„é•¿çŸ­å’ŒMemoryçš„å ç”¨ã€‚é‚è¿›è¡Œç®€å•äº†è§£ï¼Œå¹¶å°†æœ‰è¶£çš„çŸ¥è¯†ç®€è¦è®°è¿°åœ¨è¿™é‡Œã€‚
    </p>
    <br />
    <p class="reveal">
        *Runtime:<br />
        -Cache warmthï¼š instruction cacheå’Œdata cacheæ˜¯å¦è¦é‡æ–°è¯»å…¥æ•°æ®ã€‚<br />
        -Brach predictor stateï¼šè§ä¸‹æ–‡<br />
        -Heap layoutï¼šsequential accessæ¯”random accesså¿«ã€‚å› ä¸ºsequential accessåœ°å€æ˜¯è¿ç»­çš„ï¼Œè€Œrandom accessï¼ˆå¦‚ä½¿ç”¨æŒ‡é’ˆï¼‰
            æœ‰é¢å¤–çš„è°ƒç”¨è¿‡ç¨‹ï¼Œå› æ­¤èŠ±è´¹çš„æ—¶é—´ä¹Ÿæ›´å¤šã€‚<br />
        -Operating System Scheduling<br />
        *Memory:<br />
        -Paddingï¼šå¤„ç†å™¨è¯»å–æ•°æ®æ—¶æ˜¯æŒ‰ç…§å›ºå®šå¤§å°ä¸€å—ä¸€å—è¯»å–çš„ã€‚å½“æ•°æ®å¤§å°ä¸å¤Ÿæ—¶ï¼Œcompilerä¼šè‡ªåŠ¨è¡¥å……paddingï¼Œç”¨memory usageæ¢è¿è¡Œé€Ÿåº¦ã€‚<br />
        -Standard Libraryï¼šå’ŒHeap layoutç›¸å…³ã€‚ä¾‹å¦‚vectorè¿ç»­è€Œlistè¦ç”¨æŒ‡é’ˆã€‚<br />
        -Visual layoutï¼šè¿™è®©åˆ†æ”¯é¢„æµ‹å™¨éš¾ä»¥é¢„æµ‹ã€‚ä¾‹å¦‚ base-> foo()ã€‚<br />
    </p>
    <br />
    <p class="reveal">Runtime - æ—¶é’Ÿé¢‘ç‡ï¼ˆclock speedï¼‰<br />
        æ—¶é’Ÿæ¯ç§’æŒ¯åŠ¨é¢‘ç‡ï¼ˆä¸»é¢‘ï¼Œclock speedï¼‰ç›´æ¥å†³å®šäº†å¤„ç†å™¨çš„æŒ‡ä»¤æ‰§è¡Œé€Ÿåº¦ã€‚æ—¶é’Ÿæ¯æ¬¡æŒ¯åŠ¨äº§ç”Ÿè„‰å†²ä¿¡å·ï¼Œè€Œæ¯ä¸ªæ—¶é’Ÿè„‰å†²å…è®¸å¤„ç†å™¨æ‰§è¡Œä¸€æ­¥æ“ä½œã€‚
        å› æ­¤é«˜é¢‘æ„å‘³ç€å¤„ç†å™¨åœ¨å•ä½æ—¶é—´å†…äº§ç”Ÿçš„è„‰å†²ä¿¡å·æ›´å¤šï¼Œä»è€Œå¯ä»¥åœ¨å•ä½æ—¶é—´å†…å®Œæˆæ›´å¤šçš„é€»è¾‘æ“ä½œï¼ˆå¦‚æ•°æ®ä¼ è¾“ã€è®¡ç®—ç­‰ï¼‰ã€‚æ›´é«˜çš„é¢‘ç‡æ„å‘³ç€å‘¨æœŸæ—¶é—´è¶ŠçŸ­ï¼Œ
        å› æ­¤åŒä¸€æŒ‡ä»¤ä¹Ÿèƒ½åœ¨æ›´çŸ­çš„æ—¶é—´å†…å®Œæˆã€‚<br />
        æ—¶é’Ÿé¢‘ç‡è¶Šé«˜ï¼Œå¯¹èƒ½è€—å’Œæ•£çƒ­çš„è¦æ±‚å°±è¶Šé«˜ã€‚<br />
        å¤–é¢‘ï¼ˆBase clockï¼‰ï¼šä¸»æ¿æ—¶é’Ÿé¢‘ç‡ï¼Œä¸CPUå¤„ç†å™¨ä¸å¤–ç•Œï¼ˆå†…å­˜ã€ä¸»æ¿èŠ¯ç‰‡ç»„ç­‰ï¼‰äº¤æ¢æ•°æ®çš„é€Ÿåº¦ç›´æ¥æ­£ç›¸å…³ã€‚
        å€é¢‘ï¼ˆMultiplierï¼‰ï¼šä¸€ä¸ªä¹˜æ•°ï¼ˆè§ä¸‹è®¡ç®—å…¬å¼ï¼‰ï¼Œä½¿å¾—å¤„ç†å™¨èƒ½ä»¥é«˜äºå¤–éƒ¨æ€»çº¿é€Ÿåº¦è¿è¡Œã€‚<br />
        ä¸»é¢‘ = å¤–é¢‘ * å€é¢‘ <br />
        *è¶…é¢‘ï¼ˆoverclockingï¼‰ï¼šä¸€ç§ç”±äºäººä¸ºè°ƒæ•´å€é¢‘æˆ–å¤–é¢‘ä»¥ä½¿å¾—ç¡¬ä»¶è¾¾åˆ°æ›´é«˜æ€§èƒ½çš„ç°è±¡ã€‚è¶…å¤–é¢‘æå‡æ•´ä½“æ€§èƒ½ï¼Œä½†ä¼šäº§ç”Ÿä¸»æ¿è¿‡çƒ­ç­‰éšæ‚£ï¼›
        è¶…å€é¢‘ä¸»è¦å½±å“å¤„ç†å™¨é€Ÿåº¦ï¼ŒåŒæ ·å¯èƒ½ä¼šä½¿å¾—å¤„ç†å™¨è¿‡çƒ­ã€‚å› æ­¤è¶…é¢‘éœ€è¦æ³¨æ„æ•£çƒ­å’ŒåŠŸè€—ã€‚<br />
        *é™é¢‘ï¼ˆunderlockingï¼‰ï¼šå’Œè¶…é¢‘ç›¸åï¼Œé€šè¿‡äººä¸ºè°ƒæ•´å€é¢‘æˆ–å¤–é¢‘è€Œé™ä½å‘çƒ­å’ŒåŠŸè€—çš„ç°è±¡ã€‚<br />
    </p>
    <br />
    <p class="reveal">Runtime - æ—¶é’Ÿï¼ˆclockï¼‰ <br /> 
        æ—¶é’Ÿæ¯æ¬¡æŒ¯åŠ¨äº§ç”Ÿè„‰å†²ä¿¡å·ï¼Œè€Œæ¯ä¸ªæ—¶é’Ÿè„‰å†²å…è®¸å¤„ç†å™¨æ‰§è¡Œä¸€æ­¥æ“ä½œã€‚æ—¶é’Ÿæ§åˆ¶é€»è¾‘é—¨ç”µè·¯ï¼ˆlogic gateï¼‰å’Œè§¦å‘å™¨ï¼ˆtriggerï¼‰ã€‚
        è§¦å‘å™¨åœ¨æ¯æ¬¡æ”¶æ—¶é’Ÿé¢‘ç‡ï¼ˆè§ä¸‹ä¸€ä¸ªå®šä¹‰ï¼‰å¾—åˆ°æ–°çš„æ•°å€¼ï¼Œå¹¶äº¤ç”±é€»è¾‘é—¨å¤„ç†è¿è¡Œæ–°æ•°å€¼ã€‚<br />
        å°†é€»è¾‘é—¨åˆ†æ•£æˆåŒºå—ï¼Œå¹¶è®©è§¦å‘å™¨é“¾æ¥è¿™äº›å°åŒºå—ç»„ï¼Œå¯ä»¥æœ‰æ•ˆå‡å°‘æŒ‡ä»¤è¿è¡Œéœ€è¦çš„å‘¨æœŸã€‚
    </p>
    <br />
    <p class="reveal">Runtime - æŒ‡ä»¤æµæ°´çº¿ï¼ˆInstruction Pipelineï¼‰ <br />
        æŒ‡ä»¤æµæ°´çº¿ï¼ˆç®€ç§°æµæ°´çº¿ï¼‰æŒ‡å°†è®¡ç®—æœºæŒ‡ä»¤çš„å¤„ç†è¿‡ç¨‹æ‹†åˆ†ä¸ºå››ä¸ªç‹¬ç«‹æ­¥éª¤ã€å¹¶è®©ä¸åŒæŒ‡ä»¤çš„å„æ­¥æ“ä½œåœ¨ç¡¬ä»¶ä¸Šé‡å å¹¶æ‰§è¡Œçš„æŠ€æœ¯ã€‚
        è¿™å››ä¸ªç‹¬ç«‹é˜¶æ®µæŒ‰é¡ºåºä¸ºâ€œå–æŒ‡ã€è¯‘ç ã€æ‰§è¡Œã€å†™å›â€ï¼ˆFetch, Decode, Execute, Write-backï¼‰ã€‚å°†æŒ‡ä»¤æ‹†åˆ†æˆå¤šä¸ªé˜¶æ®µï¼Œæ­£å¥½å¯¹åº”å…ˆå‰é€»è¾‘é—¨è¢«åˆ†æ•£çš„
        å„ä¸ªåŒºå—ã€‚<br />
        æµæ°´çº¿çº§æ•°æ˜¯æŒ‡å¤„ç†å™¨å°†ä¸€æ¡æŒ‡ä»¤æˆ–æ“ä½œçš„å¤„ç†è¿‡ç¨‹åˆ†è§£ä¸ºè‹¥å¹²ä¸ªç‹¬ç«‹ä¸”ä¸²è¡Œçš„é˜¶æ®µã€‚è¿™äº›é˜¶æ®µçš„æ•°ç›®å³ä¸ºçº§æ•°ã€‚çº§æ•°è¶Šå¤šï¼Œæ„å‘³ç€æŒ‡ä»¤è¢«åˆ‡åˆ†å¾—
        è¶Šç»†ã€æ¯ä¸€çº§é€»è¾‘è¶Šç®€å•ï¼Œä¹Ÿæœ‰åŠ©äºæå‡å¤„ç†å™¨ä¸»é¢‘å’Œååç‡ï¼Œ
        ä½†ä¹Ÿä¼šå¸¦æ¥æ›´é«˜çš„å¯„å­˜å™¨ï¼ˆRegisterï¼‰é¢ç§¯å¼€é”€å’Œåˆ†æ”¯é¢„æµ‹ï¼ˆBranch Predictionï¼Œè§ä¸‹æ–‡ï¼‰å¤±è´¥æ—¶çš„æ¢å¤æˆæœ¬ã€‚
    </p>
    <br />
    <p class="reveal">Runtime - åˆ†æ”¯é¢„æµ‹å™¨ <br />
        åˆ†æ”¯é¢„æµ‹å™¨æ—¶ä¸€ç§æ•°å­—ç”µè·¯ã€‚å®ƒåœ¨åˆ†æ”¯æŒ‡ä»¤æ‰§è¡Œå‰ï¼Œä¼šæ ¹æ®è¿è¡Œå†å²è®°å½•å»å°è¯•è¯†åˆ«ä¸€ç§æ•°æ®åœ¨æ­¤åˆ†æ”¯æŒ‡ä»¤ä¸‹è¢«å¤„ç†çš„éšå«æ¨¡å¼ï¼Œä»è€Œåœ¨åˆ†æ”¯æŒ‡ä»¤æ‰§è¡Œçš„åŒæ—¶
        çŒœæµ‹å“ªä¸ªåˆ†æ”¯ä¼šè¢«æ‰§è¡Œï¼Œå¹¶äº‹å…ˆæ‰§è¡Œè¿™ä¸ªåç»­æ‰§è¡Œåˆ†æ”¯çš„å‘½ä»¤ã€‚<br />
        *åˆ†æ”¯æŒ‡ä»¤ï¼šæ¡ä»¶åˆ†æ”¯é€šå¸¸æœ‰ä¸¤è·¯åç»­æ‰§è¡Œåˆ†æ”¯ã€‚è‹¥åˆ¤æ–­ç»“æœä¸ºno tokenï¼Œåˆ™è·³è¿‡JMPæŒ‡ä»¤ç»§ç»­æ‰§è¡Œï¼›è‹¥åˆ¤æ–­ç»“æœä¸ºtoken,åˆ™æ‰§è¡ŒJMPæŒ‡ä»¤ï¼ˆè·³è½¬åˆ°å¦ä¸€å—
        ç¨‹åºå†…å­˜æ‰§è¡Œï¼‰<br />
        åˆ†æ”¯é¢„æµ‹å™¨å¯ä»¥é¿å…æµæ°´çº¿å†’æ³¡ï¼ˆbublingï¼‰ã€‚å¦‚æœæ²¡æœ‰åˆ†æ”¯é¢„æµ‹å™¨ï¼Œæµæ°´çº¿ä¼šç­‰åˆ°åˆ†æ”¯æŒ‡ä»¤é€šè¿‡æ‰§è¡Œé˜¶æ®µæ‰ä¼šæŠŠä¸‹ä¸€æ¡æŒ‡ä»¤é€å…¥å–æŒ‡é˜¶æ®µï¼Œç”±æ­¤ä¾¿äº§ç”Ÿäº†
        é¢å¤–çš„ç­‰å¾…æ—¶é—´ã€‚å› æ­¤åˆ†æ”¯é¢„æµ‹å™¨ä¼šåœ¨åˆ†æ”¯æŒ‡ä»¤è¿›å…¥å–æŒ‡é˜¶æ®µæ—¶æ ¹æ®è¿è¡Œå†å²è®°å½•å¯¹æŒ‡ä»¤çš„è¿è¡Œç»“æœè¿›è¡ŒçŒœæµ‹ï¼Œå¹¶æ ¹æ®çŒœæµ‹æå‰è¿è¡Œä¸€ä¸ªæ‰§è¡Œåˆ†æ”¯ä»¥å‡å°‘
        å› ä¸ºç­‰å¾…æŒ‡ä»¤è¿è¡Œè€Œé€ æˆæ½œåœ¨çš„æ—¶é—´æµªè´¹ã€‚è¿™ç§çŒœæµ‹è¯­å¥å¹¶æ‰§è¡Œçš„è¿è¡Œæ–¹æ³•å«åšæŠ•æœºæ‰§è¡Œã€‚<br />
        åœ¨åˆ†æ”¯æŒ‡ä»¤æ‰§è¡Œåï¼Œå¦‚æœåˆ†æ”¯é¢„æµ‹å™¨çŒœå¯¹äº†ï¼Œé‚£ä¹ˆæµæ°´çº¿æ­£å¸¸è¿è¡Œã€‚å¦‚æœåˆ†æ”¯é¢„æµ‹å™¨çŒœé”™äº†ï¼Œæµæ°´çº¿ä¸­æŠ•æœºæ‰§è¡Œçš„ä¸­é—´ç»“æœå…¨éƒ¨æŠ›å¼ƒï¼Œ
        å¤„ç†å™¨é‡æ–°è·å–æ­£ç¡®çš„åˆ†æ”¯è·¯çº¿ä¸Šçš„æŒ‡ä»¤æ‰§è¡Œã€‚å› æ­¤ï¼Œé¢„æµ‹å¤±è´¥ä¼šæµªè´¹å†™å›ä¹‹å‰çš„æµæ°´çº¿çº§æ•°ï¼Œæ ¹æ®ä¸åŒçš„å¤„ç†å™¨æ„é€ æŸå¤±10åˆ°20ä¸ªæ—¶é’Ÿå‘¨æœŸã€‚
    </p>
    <br />
    <br />
    
  </main>

  <!-- ğŸ”¹ Scroll reveal script -->
  <script>
    const reveals = document.querySelectorAll('.reveal');
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.1 });

    reveals.forEach(r => observer.observe(r));
  </script>
</body>

</html>


